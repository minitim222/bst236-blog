[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/xdcIkjOc)
# Homework 1: Code with AI

**Late days:** I used XX late days this time, and I have XX days remaining. (Replace the XX values with your actual numbers before submitting.)

The due date is Feb 17 at midnight. If you are using the late days, please note in the head of README.md that ‚ÄúI used XX late days this time, and I have XX days remaining‚Äù.

The main purpose of this homework is to help you:

- Get experience with AI coding
- Learn how to decompose a problem into smaller tasks and find the right tools to solve them with the help of AI
- Improve your prompt engineering skills
- Conduct the coding task you have never learned before with the help of AI
- Learn the agentic programming paradigm

**Remark**: We expect you to complete the homework with the help of AI. The tips we provide are just suggestions, and you can use other tools to complete the tasks. This homework might take longer than you expect if you have no experience with game/web development or GitHub Actions. Though this is exactly what we expect you to experience: to finish the coding tasks that you have never learned before, we suggest you **start early** in case you face unexpected issues. 

Enjoy your vibe coding!

Your homework repository should have all the source code for the problems below, though the real website could be based on the repository hosted under your own GitHub account.

In the `README.md` of your homework repository, you can write the report section as a case-study tutorial on how to use AI copilot for the following three problems. You can list the AI tools you used, and how you designed and adjusted your prompts. You can add screenshots or even share the video of how you used these AI tools and the intermediate products generated by AI if you believe it will help the readers learn.

---

## Links to my deployed website

- **Homepage (Problem 1)**: `https://minitim222.github.io/bst236-blog/`
- **Pac-Man game (Problem 2)**: `https://minitim222.github.io/bst236-blog/pacman.html`
- **arXiv feed (Problem 3)**: `https://minitim222.github.io/bst236-blog/arxiv.html`



## Problem 1. Github Website for Your Coding Blog

Create a homepage for a website for your **coding blog**. The website should be hosted on [GitHub Pages](https://pages.github.com/). You can design the homepage by yourself in any proper style you like. You may need to make the design expandable to add more content from our future assignments. The link to the homepage should be added to the `README.md` of your homework repository so that anyone can access the homepage and the following two webpages from the Internet using this link.


## Problem 2. Game Coding: Pac-Man (Valentine's Special üíò)

Add a new page to your website for a Valentine's-themed [Pac-Man](https://en.wikipedia.org/wiki/Pac-Man) game. The users can directly play the game on your webpage. The link to the game webpage should be added to the homepage in Problem 1. Your game should include the following core features:

1. **Classic Pac-Man Mechanics**: A maze with dots (pellets) for Pac-Man to eat, and ghosts that chase Pac-Man. The game ends when Pac-Man loses all lives. You can decide the maze layout by yourself (classic ok, but maybe even 3D).
2. **Valentine's Power-Up ‚Äî Rose** üåπ: A rose randomly appears on the maze from time to time. When Pac-Man eats the rose, it enters a powered-up state for a limited duration (e.g., a few seconds), during which Pac-Man **continuously shoots hearts** in its current facing direction.
3. **Heart Projectiles** üíï: The hearts travel across the maze and eliminate any ghost they hit. Once the power-up expires, Pac-Man returns to normal until it picks up another rose.

As long as the game is recognizable as a Pac-Man game by common sense, with the features roughly following the above requirements, you will get full credit.

Beyond these requirements, you are free (but will not be graded) to add your own creative touches ‚Äî such as Valentine's-themed visuals, sound effects, scoring bonuses, or additional power-ups.

## Problem 3. Data Scaffolding from the Internet

In this problem, you will build an auto-updating arXiv paper feed for your website. **You must use Copilot CLI as your primary coding tools** to scaffold, implement, and automate this task. The goal is to practice the agentic programming paradigm: break the task into agent-friendly steps, prompt the agent effectively, and wire everything together.

We suggest you to follow the steps we showed in the class: plan first with AI to decide the workflow and agents orchestration, then ask AI to implement the plan.

### Deliverables

Add a new page to your website that displays the latest arXiv papers. The page must include:

1. **Paper Listing**: The latest arXiv papers matching keywords of your choice. Design the layout as you see fit.
2. **Paper Details**: Each entry must show the paper title, authors, abstract, and a direct link to the PDF.
3. **Auto-Update**: The paper list must refresh automatically every midnight via a GitHub Actions workflow.
4. **Homepage Link**: A link to this page must appear on your homepage from Problem 1.
5. **Page Design**: Style the page in any way you think readers would appreciate.

Your homework repository **must include the `.github` directory** with all agent configurations and workflow files used for this problem.

In your report (`README.md`), describe how you used Copilot CLI to build each component. Include the prompts you gave the agent and note what worked well or required iteration.

### Tips

**Tip 1**: You can ask AI how to deploy the website by [GitHub Pages](https://pages.github.com/). 

**Tip 2**: You can ask AI to teach you how to use [arXiv API](https://arxiv.org/help/api/user-manual) to fetch the latest papers from arXiv.

**Tip 3**: You can ask AI to teach you how to use [GitHub Actions](https://docs.github.com/en/actions) to automate the process of updating the webpage. Or even leave the job to agents.

**Tip 4**: You can use [Copy Coder](https://copycoder.ai/) to help you design the webpage UI from the style you like.

---

## Report: How I used AI copilot for this homework

This homework was completed with strong help from AI coding tools in both the IDE (Cursor-style assistant) and the command line (Copilot-like CLI helpers). Below is a brief case-study of how I used these tools for each problem.

### Problem 1 ‚Äì GitHub Pages coding blog

- **Planning with AI**: I first asked the AI assistant to read the assignment and suggest a simple architecture for a static GitHub Pages site: a main `index.html` homepage, a shared `styles.css`, and separate pages for the game and arXiv feed. The assistant proposed a modern, responsive layout with a header, navigation bar, hero section, and ‚Äúfeatured sections‚Äù cards.
- **Homepage implementation**: I then prompted the assistant to generate an accessible, responsive `index.html` that links to `pacman.html` and `arxiv.html`, and to design a cohesive `styles.css` with a dark, Valentine-friendly aesthetic. I iterated by asking the AI to tweak spacing, typography, and hover states until the page looked clean and readable on both desktop and mobile.
- **Deployment guidance**: I used AI to walk me through creating a separate public repo `bst236-blog`, wiring it as a second git remote, and configuring GitHub Pages (choosing branch `main` and folder `/`). The assistant also helped me reason about the final URLs so I could correctly add the homepage link back into this homework repo‚Äôs `README.md`.

### Problem 2 ‚Äì Valentine‚Äôs Pac‚ÄëMan game

- **Game design prompts**: I asked the AI to design a tile-based Pac‚ÄëMan clone using an HTML `<canvas>` and plain JavaScript, with a simplified 28√ó28 maze, pellets, walls, ghosts, and a life/score HUD. I emphasized the homework requirements: a rose power-up, a timed powered-up state, and continuous heart projectiles that destroy ghosts.
- **Implementation with AI**: The assistant generated `pacman.html`, `pacman.css`, and `pacman.js`. We iterated on:
  - The maze layout and tile encoding (wall, pellet, empty, rose).
  - Movement logic with basic collision detection and simple tunnel wrapping.
  - A rose power-up timer that periodically spawns a rose and temporarily sets a powered-up flag.
  - Automatic heart projectiles fired in the current facing direction while powered, including collision checks that send ghosts back to their home and award bonus points.
- **Debugging and polish**: When behavior felt off (e.g., ghosts getting stuck, hearts not colliding as expected), I asked the AI to inspect the movement and collision code, explain the bug, and propose fixes. I also used AI to refine the visuals (colors, legend, overlay screen) while keeping the logic simple enough to understand.

### Problem 3 ‚Äì Auto-updating arXiv paper feed

- **Workflow planning with Copilot‚Äëstyle CLI**: Following the homework instructions, I used a terminal AI assistant (similar to Copilot CLI) to plan the full workflow:
  - Query arXiv‚Äôs API for chosen keywords.
  - Parse the Atom XML feed into a structured list of papers.
  - Render a static HTML page from a template.
  - Set up a GitHub Actions workflow that runs nightly, regenerates `arxiv.html`, and commits/pushes the result.
- **Scaffolding the script and template**: With that plan, I asked the CLI assistant to scaffold a small Python script `scripts/fetch_arxiv.py` that:
  - Builds the query URL using title/abstract keywords.
  - Fetches the Atom XML feed with a polite User-Agent.
  - Extracts title, authors, abstract, updated date, and PDF link for each entry.
  - Renders an HTML page by filling placeholders in `arxiv_template.html` (for last‚Äëupdated timestamp, query description, and a list of paper cards).
- **GitHub Actions automation**: I then asked the CLI assistant to create `.github/workflows/arxiv-update.yml` to:
  - Run on a daily `cron` schedule at midnight UTC and on manual dispatch.
  - Set up Python, run `python scripts/fetch_arxiv.py`, and commit changes to `arxiv.html` only when it actually changes.
  - Push the updated file back to GitHub so that GitHub Pages automatically serves the latest list the next time someone visits the arXiv page.
- **Iteration and verification**: With AI help, I ran the script locally to verify that `arxiv.html` rendered as expected, checked the generated HTML structure, and ensured the page links back from the homepage. I then let the workflow configuration handle the recurring nightly updates, as required by the assignment.

Overall, I used AI agents not just to generate code, but also to decompose the problems, design the file structure, debug issues, and remember small details of GitHub Pages and GitHub Actions configuration. This let me focus more on understanding the logic and less on boilerplate.

